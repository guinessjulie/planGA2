
## 요약문

```
＃ 필요부분 사용
본 연구는  경계가 주어진 주거용 건축배치에 건물의 평면도를 자동으로 생성하는 새로운 기술을 소개한다. 이 기술은 3단계 접근 방식을 채택한다. 먼저,  입력된 건축배치 내에서 개별 방의 위치를 선택한 후 인접 노드로 확장하여 평면 배치를 만든다.   두번째는 유전 알고리즘 및 시뮬레이티드 어닐링을 이용하여 평면배치를 분석해서 기하학적 적합도 및 인접성을 적합도를 계산하여 최적의 배치를 찾아낸다. 세번째는 에지 move를 사용하여 보다 방배치를 미세 조정하여 메트릭을 계산하여 기하학적으로 최적화된  방배치를 찾는다. 이 과정에서 전용 규칙을 활용하여 벽의 위치를 정제한다. 
실험 결과, 제안된 방법은 기존 방법에 근사하면서 생성 코스트가 저렴하며, 생성된 평면도가 인간이 설계한 것과 유사함을 확인하였다. 이 연구는 건축 설계 자동화의 가능성을 보여주며, 향후 건축 설계 분야에 중요한 기여를 할 것으로 기대된다.
```


# 건축 평면 자동 생성 방법 연구

## 초록

본 논문에서는 격자 기반의 공간 확장 기법과 폴리곤 변환 기법을 알고리즘을 사용하여 건축 평면도를 자동으로 생성하는 새로운 방법론을 제안한다. 제안된 방법론은 그래프 이론, 계산 기하학 및 유전 알고리즘  전략을 활용하여 미리 정의된 건축 제약 조건을 준수하는 평면도의 초기 방 배치 모델을 설계한다. 데이터 구조 및 알고리즘을 포함한 구현 세부 사항을 논의하며, 실험 결과를 통해 접근법의 효과를 입증한다.

## 1. 서론

건축 평면도의 설계는 공간적 제약과 기능적 요구 사항을 신중하게 고려해야 하는 복잡하고 시간 소모적인 작업이다. 전통적인 방법은 인간의 전문 지식과 수작업 도면에 크게 의존하며, 이는 오류가 발생하기 쉽고 비효율적이다. 본 연구는  자동화된 건축 평면도 생성 방법을 제안한다. 제안하는 방법은 격자 기반의 방배치와 돌출셀 최적화 및 폴리곤 변환 기법을 활용하여 건축 평면 설계를 자동화하는 방법을 탐구한다. 

## 2. 문헌고찰
```
＃ 번역해둔 내용 참조해서 새로 작성
Liggett과 Mitchell[2]은 각 단계에서 가장 가능성이 높은 설계 이동을 기반으로 한 번에 하나씩 방에 공간을 할당하는 건설적 배치 전략을 사용한다. 이 전략에서는 다른 방이 고려되기 전에 첫 번째 방에 사각형이 완전히 할당된다. 방은 크기 요구 사항을 충족하기 위해 그리드에 충분한 사각형을 하나씩 할당받는다. 각 방의 **배치는** **공간** **간** **이동** **비용을** **최소화하려는** **확률** **모델에** **의해** **안내된다***.** *모든* *방의* *배치가* *완료되면* *알고리즘은* *반복적인* *개선* *전략을* *사용하여* *국소* *최적해를* 찾는다**.** 이 단계에서는 설계 목표를 개선하기 위해 공간 할당이 약간 변경된다. 이러한 휴리스틱 접근 방식은 많은 상황에서 유용하지만, 글로벌 품질이나 실현 가능성을 보장하지는 않는다.
```


## [[3. 건축 도면 생성 알고리즘]]

### 3.1 시스템 개요

본 연구에서 제안하는 시스템은 다음과 같은 주요 구성 요소로 이루어진다:
1. **격자 기반 데이터 구조**:  평면도에서 특정 공간(방)은 격자 공간 내 서로 인접한 셀  집합으로 표현한다. 
2. 공간 확장 기법: 주어진 건축 공간 내에 요구 공간의 초기 공간 위치를 배치하고 이를 확장한다. 
3. 돌출셀 최적화:  격자 기반의 공간 배치에서 나타나는 계단화 현상을 제거하는 돌출셀 최적화를 진행한다. 
4. **폴리곤 기반 경계 추출**: 각 격자 셀의 경계를 따라 폴리곤을 생성하여 벡터 공간의 경계를 정의하여, 적합도를 측정하고 미세한 후공정을 제공한다.
5. **그래프 생성 및 분석**: 공간 상호간의 인접 요구 사항을 만족시키기 위해 그래프 이론을 활용하여 최적의  공간을 생성한다. 
6. **폴리곤 내보내기 및 시각화**: 최종적으로 생성된 폴리곤을 DXF 및 PNG 형식으로 내보내어 시각화한다.

### 3.2 방 배치 방법

#### 3.2.1 방의 초기 위치 선택
 
 건축배치 공간 $G_{footprint}$는 $m\times{n}$ 크기의 격자에, 건축 배치 공간(footprint)을 내부 공간과 외부 공간으로 구분하고 각 셀의 값을 1과 0 으로 설정한다.  $G$ 가 $m \times n$ 그리드일 때 $G_{footprint}$는 다음과 같다. 
 $$G_{footprint}​=\{(i, j)|g_{ij}​ = 1\}\tag{1}$$
 1. $G_{footprint}$에서 공간의 개수 $k$ 만큼 임의의 위치을 선택한다.  여기서는 이를 시드 셀 혹은 시작 셀로 명명한다. 
 2. 시드 셀에 고유한 방 번호를 할당한다. 방 번호 할당은 임의로, 미리 정의한 인접성 요구사항과 방향 요구사항을 적용/미적용한다.  각 선택된 셀 $s_i \in S$는 서로 다른 방 번호를 갖는다.  각 방의 시드 셀은  개별 공간의 형태와 크기, 위치, 그리고 방 상호간의 인접 관계를  결정하는 데 중요한 역할을 한다. 

$$G_{\text{init}} = \{g_{ij} \mid g_{ij} \in \{1, 2, \ldots, k\}, (i, j) \in S \}\tag{2} $$

여기서 $S$는 $k$개의 임의의 셀로 구성된 집합으로, $S$의 각 요소는 서로 다른 방 번호를 가지며, 그리드의 나머지 부분은 아직 할당되지 않았다. 


#### 3.2.1.2 방향 요구사항에 최적화된 시작 셀 배치

선택된 $k$개의 셀은 공간 확장의 시작 셀이므로 $k$개의 셀 $g_{ij}$ 위치에 따라 건축 배치 내 개별 공간의  방향(orientation)을 결정하게 된다. 따라서 초기 셀이 공간의 방향 요구사항을 만족하도록 $G_{init}$ 내의 다른 셀들과 교환하는 과정을 거쳐 재배치한다. 방향 요구사항은 각이 배치 공간 내에서  동서남북 어느 쪽에 위치하고자 하는지를 지정하며 방과 동서남북 방향 쌍으로 구성된다. 시작 셀 집합 $S$에서 각각 동서남북 방향의 최극단 위치를 구하고, 선택된 시작 셀 $g_{ij}$의 위치가 방향 요구사항이 지시하는 방향과 일치하는지 반복적으로 비교하여 조정한다.

성능 영향
- 각 셀이 방향 요구사항을 만족하는지 확인하고, 만족하지 않을 경우 위치를 교환하는 단계는 각 셀마다 최대 $k$번의 비교 연산이 필요하므로  최악의 경우 $O(k^2)$의 시간이 소요되고, 요구사항을 만족할 때까지 반복하는 과정은 k개의 셀이 모두 재배치될 때까지 반복되며,  각 셀이 한 번 교환될 때마다 최소한 하나의 방향 요구사항이 만족되므로, 반복 횟수는 $k$에 비례한다. 시드셀 위치 재조정 단계에서의 시간 복잡도는 $O(k^2)$이다. 그러나 일반적으로 건축 설계에서는 방의 수가 한정적이고, 각 방의 방향 요구사항이 명확히 정의되어 있으므로 알고리즘이 최적화된 형태로 동작하여, 시드 셀의 위치를 빠르게 재조정되며 추가적인 성능 낭비 없이 방향 요구사항을 초기에 조정할 수 있다. 
### 초기 방 배치 방법

k 개의 방에 대한 시작 지점을 가진 $G_{init}$에 룸을 배치하는 방법은 다음과 같은 단계로 이루어진다:



2. **경계 추출 및 폴리곤 생성**:
   - `place_room` 함수를 통해 각 룸의 경계를 추출하여 폴리곤을 생성한다. 폴리곤 생성 시 룸 간의 간격 및 정렬을 고려한다.
   - 격자 셀의 경계를 따라 폴리곤을 생성하고, 이를 통해 각 룸의 정확한 위치와 크기를 결정한다.

3. **그래프 생성 및 관계 분석**:
   - 생성된 폴리곤을 기반으로 그래프를 생성하고, 각 룸 간의 관계를 분석한다.
   - 그래프 분석을 통해 각 룸의 위치를 최적화하고, 룸 간의 접근성 및 연결성을 평가한다.

4. **최적화 및 재배치**:
   - 그래프 분석 결과를 바탕으로 룸의 위치를 최적화한다. 최적화 과정에서는 룸 간의 거리, 접근성, 기능적 요구 사항 등을 고려한다.
   - 필요에 따라 룸을 재배치하여 최적의 평면도를 생성한다.

5. **최종 폴리곤 생성 및 시각화**:
   - 최적화된 룸 배치를 기반으로 최종 폴리곤을 생성한다.
   - 생성된 폴리곤을 시각화하여 최종 평면도를 확인하고, 필요 시 수정한다.
## 방의 모양을 직사각형으로 유지하는 알고리즘  
  
### 1. 이웃 셀 수 계산  
  
그리드의 각 셀에 대해 동일한 방에 속하는 이웃 셀 수와 다른 방에 속하는 이웃 셀 수를 계산한다. 이 계산은 셀이 얼마나 단순한 직사각형 모양을 유지하는지 평가하는 데 사용된다. 그리드 셀의 특성상 이질 셀 수가 동질 셀 수에 비해 많을 경우, 해당 셀이 위치한 방의 모양이 직사각형에서 멀어지는 경향이 관찰된다.  
  
이웃 셀 수는 다음과 같이 정의된다:  
$$ \text{이질 셀 수} = \sum_{i \in \text{adj}} \mathbf{1}(f(i) \neq f(c)) $$  
$$ \text{동질 셀 수} = \sum_{i \in \text{adj}} \mathbf{1}(f(i) = f(c)) $$  
  
여기서 \( f(c) \)는 셀 \( c \)의 방 번호를 나타낸다. 이 계산을 통해 각 셀이 얼마나 단순한 직사각형 모양을 유지하는지 평가할 수 있다.  
  
### 2. 이질셀 비율 계산  
  
각 셀에 대해 다른 이웃 셀 수와 동일한 이웃 셀 수의 비율을 계산한다. 이 비율은 셀이 얼마나 직사각형 모양에서 벗어나 있는지를 평가하는 지표로 사용된다.  
  
조화 비율은 다음과 같이 정의된다:  
$$ \text{조화 비율}(c) = \frac{\text{이질 셀 수}(c)}{\text{동질 셀 수}(c)} $$  
  
조화 비율이 높을수록 해당 셀이 속한 방의 모양이 직사각형에서 멀어진다.  
  
### 3. 최대 조화 비율 탐색  
  
각 방 내에서 조화 비율이 가장 높은 셀을 찾는다. 이 셀들은 주변 환경과 가장 조화를 이루지 않는 셀들로, 이동이 필요하다.  
  
각 방 \( R \)에 대해 최대 조화 비율을 가진 셀 \( c_{\text{max}} \)는 다음과 같이 정의된다:  
$$ c_{\text{max}} = \arg\max_{c \in R} \text{조화 비율}(c) $$  
  
이 계산을 통해 각 방에서 가장 불규칙한 셀을 찾아낼 수 있다.  
  
### 4. 셀 이동  
  
조화 비율이 가장 높은 셀을 인접한 방으로 이동시켜 방의 모양이 직사각형에 가깝도록 유지한다. 이 과정은 인접한 방 중에서 조화 비율이 가장 높은 셀로 이동하도록 하여 방의 모양을 직사각형에 가깝게 유지한다.  
  
1. 셀 \( c \)의 인접한 방 $R_{\text{adj}}$를 찾는다.  
2. 각 인접한 방 내에서 조화 비율이 가장 높은 셀을 찾는다.  
3. 조화 비율이 가장 높은 셀을 새로운 위치로 이동시킨다.  
  
이를 통해 방의 모양이 최대한 단순하고 직사각형에 가깝게 유지된다.  
  
### 알고리즘 구현  
  
알고리즘은 다음과 같은 단계로 구현된다:  
  
1. **이웃 셀 수 계산**: 그리드의 각 셀에 대해 동일한 방에 속하는 이웃 셀 수와 다른 방에 속하는 이웃 셀 수를 계산한다.  
  
   1.1. 각 셀의 위치를 기준으로 상하좌우의 이웃 셀을 탐색한다.  
     
   1.2. 동일한 방에 속하는 셀과 다른 방에 속하는 셀의 수를 각각 계산한다.  
  
2. **조화 비율 계산**: 각 셀에 대해 다른 이웃 셀 수와 동일한 이웃 셀 수의 비율을 계산한다.  
  
   2.1. 계산된 이웃 셀 수를 이용하여 조화 비율을 계산한다.  
  
3. **최대 조화 비율 탐색**: 각 방 내에서 조화 비율이 가장 높은 셀을 찾는다.  
  
   3.1. 각 방의 셀들을 탐색하여 조화 비율이 가장 높은 셀을 찾는다.  
  
4. **셀 이동**: 조화 비율이 가장 높은 셀을 인접한 방으로 이동시킨다.  
  
   4.1. 인접한 방 중에서 조화 비율이 가장 높은 셀을 찾는다.  
     
   4.2. 해당 셀을 새로운 위치로 이동시킨다.  
  
이 알고리즘은 방의 모양을 가능한 한 단순하고 직사각형에 가깝게 유지하기 위해 설계되었다. 이를 통해 건축 설계에서 공간 활용도를 높이고, 효율적인 공간 배치를 이룰 수 있다.

### 4.3 돌출 셀 최적화

돌출 셀(cascading cell)을 최적화하는 알고리즘은 플로어플랜 내의 이러한 셀들을 식별하고, 유효성을 유지하면서 셀의 방 할당을 변경하여 이를 수정하는 과정을 포함한다. 아래에 이 최적화에 사용된 과정과 수학적 공식들을 자세히 설명한다.

#### 돌출 셀 식별

돌출 셀은 인접한 셀들에 기반하여 식별된다. 셀이 다른 방에 속하거나 유효하지 않은 인접 셀을 최소 세 개 이상 가지는 경우, 돌출 셀로 간주된다. 다음 함수 및 단계들이 이러한 셀을 식별하는 데 사용된다:

1. **인접 셀 분류**: 각 셀에 대해 인접 셀들을 유효하지 않은 셀, 동일한 방의 셀, 다른 방의 셀로 분류한다.
    
    - directions={(−1,0),(0,1),(1,0),(0,−1)}directions = \{(-1, 0), (0, 1), (1, 0), (0, -1)\}directions={(−1,0),(0,1),(1,0),(0,−1)}로 정의한다.
    - `count_neighbors_dirs` 함수는 인접 셀들을 분류한다.
2. **돌출 셀 판별**: 셀이 3개 이상의 다른 방이나 유효하지 않은 인접 셀을 가지면 돌출 셀로 표기된다.
    

#### 돌출 셀 최적화

돌출 셀을 최적화하기 위해 다음과 같은 절차를 수행한다:

1. **유효한 변경 판단**: 돌출 셀과 인접 셀의 방을 교환할 때, 교환 후에도 유효한 방 구성을 유지하는지를 판단한다. 이때, 유효한 교환이란 인접 셀들 중 최소 하나 이상이 동일한 방에 속하는 것을 의미한다.
2. **셀 업데이트**: 교환이 유효한 경우, 셀의 방을 업데이트하고, 돌출 셀 리스트를 갱신한다.

유효한 교환의 수학적 조건:

valid_change(cell,new_room)={Trueif ∃n∈neighbors(cell)∣floorplan[n]=new_roomFalseotherwise\text{valid\_change}(cell, new\_room) = \left\{ \begin{array}{ll} \text{True} & \text{if } \exists n \in \text{neighbors}(cell) \mid \text{floorplan}[n] = \text{new\_room} \\ \text{False} & \text{otherwise} \end{array} \right.valid_change(cell,new_room)={TrueFalse​if ∃n∈neighbors(cell)∣floorplan[n]=new_roomotherwise​

# 형태의 단순화

## `exchange_protruding_cells` 함수
주어진 `floorplan` 배열에서 삐죽삐죽한 셀(즉, 다른 방과 경계를 형성하면서 튀어나온 셀)을 찾아 이를 더 단순한 형태로 변형하는 작업을 수행한다.

삐죽삐죽한 셀(cascading cells)을 교환하여 floorplan을 단순화하는 방법은 기존의 `floorplan` 배열을 입력으로 받아, 주변 셀과의 관계를 통해 삐죽삐죽한 셀을 인접한 다른 방의 셀과 교환함으로써 보다 단순한 형태의 floorplan을 생성한다.
주어진 `create_cascading_cells` 함수는 주어진 `floorplan`에서 각 셀이 cascading cell인지 여부를 판단하여 `cascading_cells` 배열을 생성합니다. 이 배열은 각 셀이 cascading cell인지 여부를 Boolean 값으로 나타냅니다.


#### Cascading Cell의 정의

주어진 `floorplan` $\mathbf{F}$ 내에서 각 셀 $(i, j)$가 cascading cell인지 여부를 결정하기 위해,  다음과 같은 과정을 사용한다. Cascading cell은 셀이 현재 속한 방의 경계에서 튀어나와 다른 방이나 유효하지 않은 셀과 많은 경계를 형성할 때 발생한다. 

먼저, 셀 $(i, j)$의 이웃 셀(neighboring cells) 집합을 다음과 같이 정의한다:

- $\text{invalid\_neighbors}(i, j)$: 유효하지 않은 이웃 셀의 집합.
- $\text{same\_room\_neighbors}(i, j)$: 동일한 방에 속하는 이웃 셀의 집합.
- $\text{diff\_room\_neighbors}(i, j)$: 다른 방에 속하는 이웃 셀의 집합.

이때, cascading cell인지 여부는 다음과 같이 정의된다:

$$
\text{num\_diff\_invalid}(i, j) = |\text{invalid\_neighbors}(i, j)| + |\text{diff\_room\_neighbors}(i, j)|
$$

셀 $(i, j)$가 속한 방의 크기가 $2$ 이하인 경우, 해당 셀은 cascading cell이 될 수 없습니다:

$$
\text{if } |\{(i', j') \mid \mathbf{F}(i', j') = \mathbf{F}(i, j)\}| \leq 2, \text{ then } \text{cascading\_cell}(i, j) = \text{False}
$$

반면, 셀이 유효하며, $\text{num\_diff\_invalid}(i, j) \geq 3$인 경우, 해당 셀은 cascading cell로 정의됩니다:

$$
\text{cascading\_cell}(i, j) = \begin{cases} 
\text{True} & \text{if } \text{is\_valid\_cell}(\mathbf{F}, (i, j)) \text{ and } \text{num\_diff\_invalid}(i, j) \geq 3 \\
\text{False} & \text{otherwise}
\end{cases}
$$

따라서, cascading cell의 집합 $\mathbf{C}$는 다음과 같이 정의될 수 있습니다:

$$
\mathbf{C} = \{(i, j) \mid \text{cascading\_cell}(i, j) = \text{True}\}
$$

이 정의는 `floorplan` 내에서 튀어나온 셀(cascading cell)을 식별하며, 이러한 셀들은 다른 방의 셀이나 유효하지 않은 셀과 많은 경계를 형성하게 됩니다. 이로 인해 floorplan의 단순화 작업에서 제거하거나 다른 방의 셀과 교환하여 floorplan을 단순화할 수 있습니다.

---

--

위의 설명은 `create_cascading_cells` 함수의 동작 원리와 논문에 포함될 수 있는 수학적 정의를 설명하고 있습니다. 이 정의는 셀이 cascading cell인지 여부를 판단하는 과정을 수식으로 표현하고, 해당 셀들을 식별하여 집합 $\mathbf{C}$로 표현하고 있습니다.
먼저, 초기 `floorplan` $\mathbf{F}$에서 cascading cell $C$을  다음과 같이 정의된다:

$$
\mathbf{C} = \{c \in \mathbf{F} \mid \text{neighbor}(c) \neq \text{room}(c)\}
$$

이후, $\mathbf{C}$의 각 셀 $c$에 대해 인접한 셀(neighbor) 중 다른 방에 속하는 셀들을 탐색하여, 이들과의 교환을 시도한다. 방 $r$와 셀 $c$ 사이의 교환이 유효한지 판단하는 조건은 다음과 같다:

$$
\text{is\_valid\_change}(\mathbf{F}, c, r) = \begin{cases} 
\text{True} & \text{if } \text{change reduces cascading cells count} \\
\text{False} & \text{otherwise}
\end{cases}
$$

만약 유효한 교환이 가능하다면, 해당 교환을 수행하고 floorplan $\mathbf{F}$를 업데이트한다. 이 과정을 통해 floorplan의 단순화를 달성할 수 있다.

반복문이 종료된 후, 업데이트된 `floorplan` $\mathbf{F}'$는 삐죽삐죽한 셀의 개수가 감소한 최적화된 배열로 반환된다.

이 방법론은 삐죽삐죽한 셀을 제거함으로써, 최종적으로 단순하고 균형 잡힌 floorplan을 생성하는 데 기여한다.

# 격자 데이터 구조의 폴리건 구조 변환

초기 공간 구성을 위해 격자 데이터 구조를 사용하며 상하좌우로 인접된 셀의 집합으로 개별 공간을 표현한다. 공간 간의 연결성을 나타내기 위해 그래프 구조가 사용된다. 

#### 폴리곤 생성 및 경계 추출

1. **격자 셀의 경계 추출**:
   - 각 격자 셀의 경계를 따라 폴리곤을 생성한다. 이를 통해 각 공간의 경계를 명확히 정의할 수 있다.
   - 특정 공간을 나타내는 격자 셀의 꼭짓점을 추출하고, 이 꼭짓점을 연결하여 해당 공간의 외곽을 형성한다.

2. **외곽 꼭짓점 필터링**:
   - 모든 격자 셀의 꼭짓점을 수집한 후, 외곽에 위치한 꼭짓점을 필터링한다. 이는 각 셀의 경계를 명확히 정의하기 위함이다.
   - 필터링된 꼭짓점은 해당 공간의 외곽을 형성하는 데 사용된다.

3. **폴리곤 형성**:
   - 필터링된 꼭짓점을 이용하여 폴리곤을 생성한다. 이 폴리곤은 해당 공간의 정확한 외곽을 나타낸다.
   - 생성된 폴리곤은 면적, 둘레 등의 기하학적 특성을 계산하여 공간의 물리적 특성을 파악하는 데 사용된다.

### 주요 함수: create_floorplan()

`create_floorplan()` 함수는 건축 평면도를 생성하는 핵심 함수이다. 이 함수는 다음과 같은 단계로 이루어진다:

1. **초기 격자 셀 설정**:
   - 
   - `place_k_colors_on_grid` 함수를 사용하여, k개의 초기 색상을 랜덤한 위치에 격자에 배치한다.  
2. 방향 요구사항에 따라 초기 시드 셀의 방을 교환한다. 

2. **격자 셀 분석**:
   - 각 셀의 위치와 크기를 분석하여, 룸의 경계를 추출한다.
   - 경계 추출 시, 각 셀의 꼭짓점을 이용하여 폴리곤을 생성한다.

3. **그래프 생성**:
   - 격자 셀 데이터를 기반으로 그래프를 생성한다. 각 셀은 그래프의 노드가 되며, 인접한 셀 간의 연결성은 엣지로 표현된다.

4. **최적화 및 재배치**:
   - 그래프를 분석하여 룸 간의 최적의 배치를 결정한다.
   - 최적화 과정에서는 룸의 면적, 둘레, 접근성 등을 고려하여 배치를 조정한다.
   - `place_room` 함수를 사용하여, 각 룸을 최적화된 위치에 배치한다.

5. **최종 폴리곤 생성**:
   - 최적화된 격자 셀 배열을 기반으로 최종 폴리곤을 생성한다.
   - 생성된 폴리곤은 각 룸의 경계를 명확히 정의하며, 이를 시각화하여 최종 평면도를 확인할 수 있다.


## 전체 알고리즘 정리(참조)

첫 번째 단계에서 k 개의 무작위 위치 선택하여 시작한다.  이 위치는 방향 요구사항에 따라 초기 개별방의 위치가 정해진다. 기능과 인접 셀 기반으로 개별 공간을 확장해 나간다.   그런 다음 두 번째 단계(SHC 검색)를 시작하며, 여기서 개체들은 Eq. (1)에 표현된 목적 함수에 따라 평가되고 순위가 매겨진다. 개체의 평가는 연결성/접근성, 바닥 겹침, 열림 겹침, 열림 방향, 바닥 치수, 바닥 계획의 압축성, 공간 넘침 등 7개의 평가 축에 초점을 맞춘다. 이러한 모든 항목은 최소화될 가중 합 목표 함수로 모인다. 서로 다른 가중치는 각 목표를 중요도에 따라 순위를 매기도록 허용한다.

이 단계의 다음 단계는 두 번째 단계에 대한 종료 조건이 충족되었는지 확인하는 것이다. 만약 마지막 5번의 SHC 검색 주기에서 엘리트 그룹의 적합도 평균이 Eq. (21)에서 구한 부정적인 평가자 가중치 평균보다 크다면, 두 번째 단계가 끝나고 제안된 기술(ES 검색)의 첫 번째 단계로 돌아간다. 그렇지 않으면 SHC 검색 방법이 계속되어 각 개체에 SHC 연산자 그룹을 적용한다. 이들 연산자는 개체의 열림, 공간 클러스터 및 전체 개체에서 확률적 기하학적 변환을 수행한다. 그런 다음 개체들은 평가되고 순위가 매겨지며 종료 조건이 다시 평가된다.
### 요구사항
1인용 침대 및 책상, 책장, 옷장을 수납할 수 있는 최소한의 방의 크기는 보통 2900 × 2700 을 잡습니다. 

표준적인 크기는 3600 × 2700, 조금 여유가 있는 정도가  3600 × 3000 입니다

출처: [https://next-archi.tistory.com/65](https://next-archi.tistory.com/65) [건축 지식 저장소:티스토리]

## 결론

본 연구에서 제안한 격자 기반 및 폴리곤 기반 알고리즘을 활용한 건축 평면도 자동 생성 방법론은 설계 효율성을 크게 향상시키고, 오류를 줄이며, 보다 신속하고 정확한 건축 설계를 가능하게 한다. 이를 통해 건축 설계의 자동화와 디지털화를 촉진할 수 있을 것으로 기대된다.

---

이 논문 초판은 격자와 폴리곤을 이용한 건축 평면도 자동 생성 방법론을 설명하는 데 중점을 두었으며, 각 단계에서 사용된 주요 알고리즘과 데이터 구조를 건축적 용어로 설명했습니다. 추가적인 구현 세부 사항과 실험 결과는 본 논문의 후속 연구에서 다루어질 수 있습니다.